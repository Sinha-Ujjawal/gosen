//! Generated by Snowball 2.2.0 - https://snowballstem.org/

package snowball

var A_0 = []*Among{
    {Str: "arsen", A: -1, B: -1, F: nil},
    {Str: "commun", A: -1, B: -1, F: nil},
    {Str: "gener", A: -1, B: -1, F: nil},
}

var A_1 = []*Among{
    {Str: "'", A: -1, B: 1, F: nil},
    {Str: "'s'", A: 0, B: 1, F: nil},
    {Str: "'s", A: -1, B: 1, F: nil},
}

var A_2 = []*Among{
    {Str: "ied", A: -1, B: 2, F: nil},
    {Str: "s", A: -1, B: 3, F: nil},
    {Str: "ies", A: 1, B: 2, F: nil},
    {Str: "sses", A: 1, B: 1, F: nil},
    {Str: "ss", A: 1, B: -1, F: nil},
    {Str: "us", A: 1, B: -1, F: nil},
}

var A_3 = []*Among{
    {Str: "", A: -1, B: 3, F: nil},
    {Str: "bb", A: 0, B: 2, F: nil},
    {Str: "dd", A: 0, B: 2, F: nil},
    {Str: "ff", A: 0, B: 2, F: nil},
    {Str: "gg", A: 0, B: 2, F: nil},
    {Str: "bl", A: 0, B: 1, F: nil},
    {Str: "mm", A: 0, B: 2, F: nil},
    {Str: "nn", A: 0, B: 2, F: nil},
    {Str: "pp", A: 0, B: 2, F: nil},
    {Str: "rr", A: 0, B: 2, F: nil},
    {Str: "at", A: 0, B: 1, F: nil},
    {Str: "tt", A: 0, B: 2, F: nil},
    {Str: "iz", A: 0, B: 1, F: nil},
}

var A_4 = []*Among{
    {Str: "ed", A: -1, B: 2, F: nil},
    {Str: "eed", A: 0, B: 1, F: nil},
    {Str: "ing", A: -1, B: 2, F: nil},
    {Str: "edly", A: -1, B: 2, F: nil},
    {Str: "eedly", A: 3, B: 1, F: nil},
    {Str: "ingly", A: -1, B: 2, F: nil},
}

var A_5 = []*Among{
    {Str: "anci", A: -1, B: 3, F: nil},
    {Str: "enci", A: -1, B: 2, F: nil},
    {Str: "ogi", A: -1, B: 13, F: nil},
    {Str: "li", A: -1, B: 15, F: nil},
    {Str: "bli", A: 3, B: 12, F: nil},
    {Str: "abli", A: 4, B: 4, F: nil},
    {Str: "alli", A: 3, B: 8, F: nil},
    {Str: "fulli", A: 3, B: 9, F: nil},
    {Str: "lessli", A: 3, B: 14, F: nil},
    {Str: "ousli", A: 3, B: 10, F: nil},
    {Str: "entli", A: 3, B: 5, F: nil},
    {Str: "aliti", A: -1, B: 8, F: nil},
    {Str: "biliti", A: -1, B: 12, F: nil},
    {Str: "iviti", A: -1, B: 11, F: nil},
    {Str: "tional", A: -1, B: 1, F: nil},
    {Str: "ational", A: 14, B: 7, F: nil},
    {Str: "alism", A: -1, B: 8, F: nil},
    {Str: "ation", A: -1, B: 7, F: nil},
    {Str: "ization", A: 17, B: 6, F: nil},
    {Str: "izer", A: -1, B: 6, F: nil},
    {Str: "ator", A: -1, B: 7, F: nil},
    {Str: "iveness", A: -1, B: 11, F: nil},
    {Str: "fulness", A: -1, B: 9, F: nil},
    {Str: "ousness", A: -1, B: 10, F: nil},
}

var A_6 = []*Among{
    {Str: "icate", A: -1, B: 4, F: nil},
    {Str: "ative", A: -1, B: 6, F: nil},
    {Str: "alize", A: -1, B: 3, F: nil},
    {Str: "iciti", A: -1, B: 4, F: nil},
    {Str: "ical", A: -1, B: 4, F: nil},
    {Str: "tional", A: -1, B: 1, F: nil},
    {Str: "ational", A: 5, B: 2, F: nil},
    {Str: "ful", A: -1, B: 5, F: nil},
    {Str: "ness", A: -1, B: 5, F: nil},
}

var A_7 = []*Among{
    {Str: "ic", A: -1, B: 1, F: nil},
    {Str: "ance", A: -1, B: 1, F: nil},
    {Str: "ence", A: -1, B: 1, F: nil},
    {Str: "able", A: -1, B: 1, F: nil},
    {Str: "ible", A: -1, B: 1, F: nil},
    {Str: "ate", A: -1, B: 1, F: nil},
    {Str: "ive", A: -1, B: 1, F: nil},
    {Str: "ize", A: -1, B: 1, F: nil},
    {Str: "iti", A: -1, B: 1, F: nil},
    {Str: "al", A: -1, B: 1, F: nil},
    {Str: "ism", A: -1, B: 1, F: nil},
    {Str: "ion", A: -1, B: 2, F: nil},
    {Str: "er", A: -1, B: 1, F: nil},
    {Str: "ous", A: -1, B: 1, F: nil},
    {Str: "ant", A: -1, B: 1, F: nil},
    {Str: "ent", A: -1, B: 1, F: nil},
    {Str: "ment", A: 15, B: 1, F: nil},
    {Str: "ement", A: 16, B: 1, F: nil},
}

var A_8 = []*Among{
    {Str: "e", A: -1, B: 1, F: nil},
    {Str: "l", A: -1, B: 2, F: nil},
}

var A_9 = []*Among{
    {Str: "succeed", A: -1, B: -1, F: nil},
    {Str: "proceed", A: -1, B: -1, F: nil},
    {Str: "exceed", A: -1, B: -1, F: nil},
    {Str: "canning", A: -1, B: -1, F: nil},
    {Str: "inning", A: -1, B: -1, F: nil},
    {Str: "earring", A: -1, B: -1, F: nil},
    {Str: "herring", A: -1, B: -1, F: nil},
    {Str: "outing", A: -1, B: -1, F: nil},
}

var A_10 = []*Among{
    {Str: "andes", A: -1, B: -1, F: nil},
    {Str: "atlas", A: -1, B: -1, F: nil},
    {Str: "bias", A: -1, B: -1, F: nil},
    {Str: "cosmos", A: -1, B: -1, F: nil},
    {Str: "dying", A: -1, B: 3, F: nil},
    {Str: "early", A: -1, B: 9, F: nil},
    {Str: "gently", A: -1, B: 7, F: nil},
    {Str: "howe", A: -1, B: -1, F: nil},
    {Str: "idly", A: -1, B: 6, F: nil},
    {Str: "lying", A: -1, B: 4, F: nil},
    {Str: "news", A: -1, B: -1, F: nil},
    {Str: "only", A: -1, B: 10, F: nil},
    {Str: "singly", A: -1, B: 11, F: nil},
    {Str: "skies", A: -1, B: 2, F: nil},
    {Str: "skis", A: -1, B: 1, F: nil},
    {Str: "sky", A: -1, B: -1, F: nil},
    {Str: "tying", A: -1, B: 5, F: nil},
    {Str: "ugly", A: -1, B: 8, F: nil},
}

var G_aeo = []byte{17, 64}

var G_v = []byte{17, 65, 16, 1}

var G_v_WXY = []byte{1, 17, 65, 208, 1}

var G_valid_LI = []byte{55, 141, 2}

type Context struct {
    b_Y_found bool
    i_p2      int
    i_p1      int
}

type EnglishStemmer struct {
    Env
}

func r_prelude(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    context.b_Y_found = false
    var v_1 = env.Cursor
lab0:
    for {
        env.Bra = env.Cursor
        if !env.EqS("'") {
            break lab0
        }
        env.Ket = env.Cursor
        if !env.SliceDel() {
            return false
        }
        break lab0
    }
    env.Cursor = v_1
    var v_2 = env.Cursor
lab1:
    for {
        env.Bra = env.Cursor
        if !env.EqS("y") {
            break lab1
        }
        env.Ket = env.Cursor
        if !env.SliceFrom("Y") {
            return false
        }
        context.b_Y_found = true
        break lab1
    }
    env.Cursor = v_2
    var v_3 = env.Cursor
lab2:
    for {
    replab3:
        for {
            var v_4 = env.Cursor
        lab4:
            for range [2]struct{}{} {
            golab5:
                for {
                    var v_5 = env.Cursor
                lab6:
                    for {
                        if !env.InGrouping(G_v, 97, 121) {
                            break lab6
                        }
                        env.Bra = env.Cursor
                        if !env.EqS("y") {
                            break lab6
                        }
                        env.Ket = env.Cursor
                        env.Cursor = v_5
                        break golab5
                    }
                    env.Cursor = v_5
                    if env.Cursor >= env.Limit {
                        break lab4
                    }
                    env.NextChar()
                }
                if !env.SliceFrom("Y") {
                    return false
                }
                context.b_Y_found = true
                continue replab3
            }
            env.Cursor = v_4
            break replab3
        }
        break lab2
    }
    env.Cursor = v_3
    return true
}

func r_mark_regions(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    context.i_p1 = env.Limit
    context.i_p2 = env.Limit
    var v_1 = env.Cursor
lab0:
    for {
    lab1:
        for {
            var v_2 = env.Cursor
        lab2:
            for {
                if env.FindAmong(A_0, context) == 0 {
                    break lab2
                }
                break lab1
            }
            env.Cursor = v_2
        golab3:
            for {
            lab4:
                for {
                    if !env.InGrouping(G_v, 97, 121) {
                        break lab4
                    }
                    break golab3
                }
                if env.Cursor >= env.Limit {
                    break lab0
                }
                env.NextChar()
            }
        golab5:
            for {
            lab6:
                for {
                    if !env.OutGrouping(G_v, 97, 121) {
                        break lab6
                    }
                    break golab5
                }
                if env.Cursor >= env.Limit {
                    break lab0
                }
                env.NextChar()
            }
            break lab1
        }
        context.i_p1 = env.Cursor
    golab7:
        for {
        lab8:
            for {
                if !env.InGrouping(G_v, 97, 121) {
                    break lab8
                }
                break golab7
            }
            if env.Cursor >= env.Limit {
                break lab0
            }
            env.NextChar()
        }
    golab9:
        for {
        lab10:
            for {
                if !env.OutGrouping(G_v, 97, 121) {
                    break lab10
                }
                break golab9
            }
            if env.Cursor >= env.Limit {
                break lab0
            }
            env.NextChar()
        }
        context.i_p2 = env.Cursor
        break lab0
    }
    env.Cursor = v_1
    return true
}

func r_shortv(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
lab0:
    for {
        var v_1 = env.Limit - env.Cursor
    lab1:
        for {
            if !env.OutGroupingB(G_v_WXY, 89, 121) {
                break lab1
            }
            if !env.InGroupingB(G_v, 97, 121) {
                break lab1
            }
            if !env.OutGroupingB(G_v, 97, 121) {
                break lab1
            }
            break lab0
        }
        env.Cursor = env.Limit - v_1
        if !env.OutGroupingB(G_v, 97, 121) {
            return false
        }
        if !env.InGroupingB(G_v, 97, 121) {
            return false
        }
        if env.Cursor > env.LimitBackward {
            return false
        }
        break lab0
    }
    return true
}

func r_R1(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    return context.i_p1 <= env.Cursor
}

func r_R2(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    return context.i_p2 <= env.Cursor
}

func r_Step_1a(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    var v_1 = env.Limit - env.Cursor
lab0:
    for {
        env.Ket = env.Cursor
        if env.FindAmongB(A_1, context) == 0 {
            env.Cursor = env.Limit - v_1
            break lab0
        }
        env.Bra = env.Cursor
        if !env.SliceDel() {
            return false
        }
        break lab0
    }
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_2, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    switch among_var {
    case 1:
        if !env.SliceFrom("ss") {
            return false
        }
    case 2:
    lab1:
        for {
            var v_2 = env.Limit - env.Cursor
        lab2:
            for {
                if !env.HopBack(2) {
                    break lab2
                }
                if !env.SliceFrom("i") {
                    return false
                }
                break lab1
            }
            env.Cursor = env.Limit - v_2
            if !env.SliceFrom("ie") {
                return false
            }
            break lab1
        }
    case 3:
        if env.Cursor <= env.LimitBackward {
            return false
        }
        env.PrevChar()
    golab3:
        for {
        lab4:
            for {
                if !env.InGroupingB(G_v, 97, 121) {
                    break lab4
                }
                break golab3
            }
            if env.Cursor <= env.LimitBackward {
                return false
            }
            env.PrevChar()
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_1b(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_4, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    switch among_var {
    case 1:
        if !r_R1(env, context) {
            return false
        }
        if !env.SliceFrom("ee") {
            return false
        }
    case 2:
        var v_1 = env.Limit - env.Cursor
    golab0:
        for {
        lab1:
            for {
                if !env.InGroupingB(G_v, 97, 121) {
                    break lab1
                }
                break golab0
            }
            if env.Cursor <= env.LimitBackward {
                return false
            }
            env.PrevChar()
        }
        env.Cursor = env.Limit - v_1
        if !env.SliceDel() {
            return false
        }
        env.Ket = env.Cursor
        env.Bra = env.Cursor
        var v_3 = env.Limit - env.Cursor
        among_var = env.FindAmongB(A_3, context)
        switch among_var {
        case 1:
            if !env.SliceFrom("e") {
                return false
            }
            return false
        case 2:
            var v_4 = env.Limit - env.Cursor
        lab2:
            for {
                if !env.InGroupingB(G_aeo, 97, 111) {
                    break lab2
                }
                if env.Cursor > env.LimitBackward {
                    break lab2
                }
                return false
            }
            env.Cursor = env.Limit - v_4
        case 3:
            if env.Cursor != context.i_p1 {
                return false
            }
            var v_5 = env.Limit - env.Cursor
            if !r_shortv(env, context) {
                return false
            }
            env.Cursor = env.Limit - v_5
            if !env.SliceFrom("e") {
                return false
            }
            return false
        }
        env.Cursor = env.Limit - v_3
        env.Ket = env.Cursor
        if env.Cursor <= env.LimitBackward {
            return false
        }
        env.PrevChar()
        env.Bra = env.Cursor
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_1c(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    env.Ket = env.Cursor
lab0:
    for {
        var v_1 = env.Limit - env.Cursor
    lab1:
        for {
            if !env.EqSB("y") {
                break lab1
            }
            break lab0
        }
        env.Cursor = env.Limit - v_1
        if !env.EqSB("Y") {
            return false
        }
        break lab0
    }
    env.Bra = env.Cursor
    if !env.OutGroupingB(G_v, 97, 121) {
        return false
    }
lab2:
    for {
        if env.Cursor > env.LimitBackward {
            break lab2
        }
        return false
    }
    if !env.SliceFrom("i") {
        return false
    }
    return true
}

func r_Step_2(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_5, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    if !r_R1(env, context) {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceFrom("tion") {
            return false
        }
    case 2:
        if !env.SliceFrom("ence") {
            return false
        }
    case 3:
        if !env.SliceFrom("ance") {
            return false
        }
    case 4:
        if !env.SliceFrom("able") {
            return false
        }
    case 5:
        if !env.SliceFrom("ent") {
            return false
        }
    case 6:
        if !env.SliceFrom("ize") {
            return false
        }
    case 7:
        if !env.SliceFrom("ate") {
            return false
        }
    case 8:
        if !env.SliceFrom("al") {
            return false
        }
    case 9:
        if !env.SliceFrom("ful") {
            return false
        }
    case 10:
        if !env.SliceFrom("ous") {
            return false
        }
    case 11:
        if !env.SliceFrom("ive") {
            return false
        }
    case 12:
        if !env.SliceFrom("ble") {
            return false
        }
    case 13:
        if !env.EqSB("l") {
            return false
        }
        if !env.SliceFrom("og") {
            return false
        }
    case 14:
        if !env.SliceFrom("less") {
            return false
        }
    case 15:
        if !env.InGroupingB(G_valid_LI, 99, 116) {
            return false
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_3(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_6, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    if !r_R1(env, context) {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceFrom("tion") {
            return false
        }
    case 2:
        if !env.SliceFrom("ate") {
            return false
        }
    case 3:
        if !env.SliceFrom("al") {
            return false
        }
    case 4:
        if !env.SliceFrom("ic") {
            return false
        }
    case 5:
        if !env.SliceDel() {
            return false
        }
    case 6:
        if !r_R2(env, context) {
            return false
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_4(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_7, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    if !r_R2(env, context) {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceDel() {
            return false
        }
    case 2:
    lab0:
        for {
            var v_1 = env.Limit - env.Cursor
        lab1:
            for {
                if !env.EqSB("s") {
                    break lab1
                }
                break lab0
            }
            env.Cursor = env.Limit - v_1
            if !env.EqSB("t") {
                return false
            }
            break lab0
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_5(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_8, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    switch among_var {
    case 1:
    lab0:
        for {
            var v_1 = env.Limit - env.Cursor
        lab1:
            for {
                if !r_R2(env, context) {
                    break lab1
                }
                break lab0
            }
            env.Cursor = env.Limit - v_1
            if !r_R1(env, context) {
                return false
            }
            var v_2 = env.Limit - env.Cursor
        lab2:
            for {
                if !r_shortv(env, context) {
                    break lab2
                }
                return false
            }
            env.Cursor = env.Limit - v_2
            break lab0
        }
        if !env.SliceDel() {
            return false
        }
    case 2:
        if !r_R2(env, context) {
            return false
        }
        if !env.EqSB("l") {
            return false
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_exception2(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    env.Ket = env.Cursor
    if env.FindAmongB(A_9, context) == 0 {
        return false
    }
    env.Bra = env.Cursor
    if env.Cursor > env.LimitBackward {
        return false
    }
    return true
}

func r_exception1(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Bra = env.Cursor
    among_var = env.FindAmong(A_10, context)
    if among_var == 0 {
        return false
    }
    env.Ket = env.Cursor
    if env.Cursor < env.Limit {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceFrom("ski") {
            return false
        }
    case 2:
        if !env.SliceFrom("sky") {
            return false
        }
    case 3:
        if !env.SliceFrom("die") {
            return false
        }
    case 4:
        if !env.SliceFrom("lie") {
            return false
        }
    case 5:
        if !env.SliceFrom("tie") {
            return false
        }
    case 6:
        if !env.SliceFrom("idl") {
            return false
        }
    case 7:
        if !env.SliceFrom("gentl") {
            return false
        }
    case 8:
        if !env.SliceFrom("ugli") {
            return false
        }
    case 9:
        if !env.SliceFrom("earli") {
            return false
        }
    case 10:
        if !env.SliceFrom("onli") {
            return false
        }
    case 11:
        if !env.SliceFrom("singl") {
            return false
        }
    }
    return true
}

func r_postlude(env *EnglishStemmer, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    if !context.b_Y_found {
        return false
    }
replab0:
    for {
        var v_1 = env.Cursor
    lab1:
        for range [2]struct{}{} {
        golab2:
            for {
                var v_2 = env.Cursor
            lab3:
                for {
                    env.Bra = env.Cursor
                    if !env.EqS("Y") {
                        break lab3
                    }
                    env.Ket = env.Cursor
                    env.Cursor = v_2
                    break golab2
                }
                env.Cursor = v_2
                if env.Cursor >= env.Limit {
                    break lab1
                }
                env.NextChar()
            }
            if !env.SliceFrom("y") {
                return false
            }
            continue replab0
        }
        env.Cursor = v_1
        break replab0
    }
    return true
}

func (env *EnglishStemmer) Stem(token string) string {
    env.SetCurrent(token)
    var context = &Context{
        b_Y_found: false,
        i_p2:      0,
        i_p1:      0,
    }
    _ = context
lab0:
    for {
        var v_1 = env.Cursor
    lab1:
        for {
            if !r_exception1(env, context) {
                break lab1
            }
            break lab0
        }
        env.Cursor = v_1
    lab2:
        for {
            var v_2 = env.Cursor
        lab3:
            for {
                if !env.Hop(3) {
                    break lab3
                }
                break lab2
            }
            env.Cursor = v_2
            break lab0
        }
        env.Cursor = v_1
        r_prelude(env, context)
        r_mark_regions(env, context)
        env.LimitBackward = env.Cursor
        env.Cursor = env.Limit
        var v_5 = env.Limit - env.Cursor
        r_Step_1a(env, context)
        env.Cursor = env.Limit - v_5
    lab4:
        for {
            var v_6 = env.Limit - env.Cursor
        lab5:
            for {
                if !r_exception2(env, context) {
                    break lab5
                }
                break lab4
            }
            env.Cursor = env.Limit - v_6
            var v_7 = env.Limit - env.Cursor
            r_Step_1b(env, context)
            env.Cursor = env.Limit - v_7
            var v_8 = env.Limit - env.Cursor
            r_Step_1c(env, context)
            env.Cursor = env.Limit - v_8
            var v_9 = env.Limit - env.Cursor
            r_Step_2(env, context)
            env.Cursor = env.Limit - v_9
            var v_10 = env.Limit - env.Cursor
            r_Step_3(env, context)
            env.Cursor = env.Limit - v_10
            var v_11 = env.Limit - env.Cursor
            r_Step_4(env, context)
            env.Cursor = env.Limit - v_11
            var v_12 = env.Limit - env.Cursor
            r_Step_5(env, context)
            env.Cursor = env.Limit - v_12
            break lab4
        }
        env.Cursor = env.LimitBackward
        var v_13 = env.Cursor
        r_postlude(env, context)
        env.Cursor = v_13
        break lab0
    }
    return env.Current()
}
